# EXPT-06-Detecting-and-Exploiting-XSS.md

_(Copy this whole file into your repo as `EXPT-06-Detecting-and-Exploiting-XSS.md`. — **Note:** this file **does not** include Mutillidae install steps — it assumes Mutillidae is already installed and reachable at `http://localhost/mutillidae/`.)_

---

# Experiment 6 — Detecting & Exploiting XSS (Kali + Mutillidae + Burp)

**Platform:** Kali Linux + Mutillidae (or DVWA) + Burp Suite + browser devtools
**Purpose (one-liner):** find and demonstrate Reflected, Stored and DOM XSS on a lab target; capture clean evidence (requests / PoC) to show the examiner; and describe mitigations.
**Ethics & scope:** Only test authorized lab targets. Keep payloads minimal and non-destructive; do not exfiltrate real user data. ([OWASP][1])

---

## Contents

1. Short theory: what XSS is and its types (exam-ready)
2. Prerequisites (software + lab)
3. Quick checklist (one-page)
4. Step-by-step — Reflected XSS (Mutillidae)
5. Step-by-step — Stored XSS (Mutillidae)
6. Step-by-step — DOM XSS (how to detect & prove)
7. Fallback: DVWA / alternative methods if Mutillidae fails
8. Useful payloads & encoding tips (safe, exam-friendly)
9. What to capture & sample evidence filenames to show teacher
10. Mitigations / recommended fixes (copy-paste lines for viva)
11. Minimal lab report template (copy-paste)
12. Appendix — commands, Burp tips & quick checklist

---

## 1) Short theory (2–3 sentences you can say to teacher)

Cross-Site Scripting (XSS) is a client-side injection where an attacker gets the application to send JavaScript to other users’ browsers; impact ranges from UI defacement to cookie theft and account takeover. There are three common forms: **Reflected** (payload comes from a request and is reflected in the response), **Stored** (payload is saved on server and served to other users), and **DOM-based** (vulnerability lives purely in client-side JavaScript that writes attacker-controlled data to the page). ([PortSwigger][2])

---

## 2) Prerequisites (what must be ready on your Kali machine)

- Kali Linux (updated).
- Mutillidae running at `http://localhost/mutillidae/` (or lab host).
- Burp Suite (Community or Pro). Repeater/Proxy always available; Scanner only in Pro.
- Firefox (recommended) with Burp CA installed or use Burp embedded browser.
- A small `~/expt06/` workspace to save evidence.
- Basic knowledge of browser DevTools (Console/Elements/Network).

---

## 3) Quick checklist (one-page before starting exam)

- [ ] Start Apache & MySQL if needed: `sudo systemctl start apache2 && sudo systemctl start mariadb`
- [ ] Open `http://localhost/mutillidae/` in proxied browser; verify Burp Proxy → HTTP history is capturing.
- [ ] Add host to Burp **Target → Scope**.
- [ ] For reflected: locate a parameter that echoes input (search, image Q, redirect).
- [ ] For stored: find a comment/feedback/profile field that persists input.
- [ ] For DOM: open pages and inspect JS handling of `location`, `hash`, `innerHTML`, `document.write`.
- [ ] Save screenshots & raw request/response files to `~/expt06/evidence/`.

---

## 4) Reflected XSS — step-by-step (Mutillidae)

**Goal:** inject a simple payload into a parameter that is immediately reflected and executed.

### A. Identify candidate endpoint

1. Open Mutillidae in your proxied browser. Browse options likely to reflect input: search boxes, image/question pages, redirect parameters, or `?page=` type parameters. (Mutillidae has many intentionally vulnerable demo pages.) ([computersecuritystudent.com][3])

### B. Capture the request in Burp

1. In Burp: **Proxy → Intercept Off** (so browsing flows).
2. Perform a sample input (e.g., search for `test`) and locate the corresponding request in **Proxy → HTTP history**. Right-click → **Send to Repeater**.

### C. Simple PoC payload (non-destructive)

- Use: `<script>alert(1)</script>`
- URL-encoded form (if needed): `%3Cscript%3Ealert(1)%3C%2Fscript%3E`

### D. Repeater test

1. In **Repeater**, replace the parameter value with the payload, click **Go**.
2. Observe response HTML for the payload reflected unencoded, or execute in browser to get a popup. If Burp shows the payload in the response body, take a screenshot. Save the raw response (right-click → Save item).

**Evidence to save**

- `evidence/01_reflected_request.txt` (raw request)
- `evidence/02_reflected_response.png` (screenshot showing payload in response or browser alert)

**Notes**

- If the page sanitizes HTML, try `"><img src=x onerror=alert(1)>` or URL-encode payload. PortSwigger’s XSS cheat sheets have alternative vectors. ([PortSwigger][4])

---

## 5) Stored XSS — step-by-step (Mutillidae)

**Goal:** inject payload into persistent data (comment, profile bio), then view it as another user.

### A. Find a persisted input (comments/profile)

1. In Mutillidae, locate pages like “Blog”, “Feedback”, “Add comment”, or user profile edit.
2. Submit a comment containing a PoC payload: `<script>alert('XSS-stored')</script>` (or a non-popup proof for teacher like `<img src=x onerror=console.log(document.cookie)>`).

### B. Submit & view

1. Submit the comment and then navigate to the page that lists comments (or open in a different browser session if you want to demonstrate "other user" effect).
2. If the payload executes when the page is viewed, you have stored XSS. Capture: screenshot of page rendering alert or console output. Save raw POST and the page where it appears.

**Evidence to save**

- `evidence/03_stored_post_request.txt` (raw POST)
- `evidence/04_stored_view.png` (screenshot showing alert / payload in page)

**Notes**

- In exam, explain stored XSS is more severe because every visitor can be affected. Cite OWASP for impact. ([PortSwigger][5])

---

## 6) DOM XSS — detection & proof (client-side only)

**Goal:** detect when client JS reads attacker-controlled data (`location.search`, `location.hash`, `document.referrer`, cookies) and writes it into the DOM unsafely (e.g., `innerHTML`, `eval`, `document.write`).

### A. Inspect JS sinks and sources

1. Open the target page and open **DevTools → Sources / Elements**. Search for uses of `innerHTML`, `document.write`, `eval`, `location.hash`, `location.search`, `document.cookie`.
2. If the page reads `location.hash` or `location.search` and writes it directly into `innerHTML`, it is suspicious. PortSwigger has guides and labs for DOM XSS patterns. ([PortSwigger][6])

### B. Craft the PoC

1. If the page uses `location.hash`, craft a URL:

   ```
   http://<target>/page#<img src=x onerror=alert(1)>
   ```

2. Open that URL in browser. If the payload executes without any server involvement, it’s DOM XSS.

### C. Prove & capture

1. Use DevTools Console to run `document.location.hash` and watch how the page processes it, or set breakpoints in the JS function that writes to the DOM then reload the PoC URL.
2. Save screenshots: `evidence/05_dom_poc.png` (DevTools showing sink with payload) and `evidence/06_dom_alert.png` (alert or console evidence).

**Notes**

- DOM XSS can be invisible to server logs because the payload never hits the server. Explain this to the teacher with a quick DevTools demo. ([OWASP Cheat Sheet Series][7])

---

## 7) Fallback: DVWA / alternative approaches (if Mutillidae fails)

If Mutillidae is not reachable, use **DVWA** (has Reflected & Stored XSS modules) or OWASP Juice Shop for practice. Steps map 1:1: find an input, insert payload, view results. In DVWA set **Security → low** to see obvious XSS. ([101Labs.net][8])

---

## 8) Useful payloads & encoding tips (safe & compact)

**Simple audible/test PoCs**

- `<script>alert(1)</script>` — classic.
- `"><img src=x onerror=alert(1)>` — attribute-context bypass.
- `<svg/onload=alert(1)>` — alternate tag.
- For DOM hash: `#<img src=x onerror=alert(1)>`

**URL-encoded versions (when parameter sanitization blocks raw `<`):**

- `%3Cscript%3Ealert(1)%3C%2Fscript%3E`

**Filter-evasion references:** use OWASP XSS Filter Evasion and PortSwigger cheat sheets when a simple payload is filtered — but in exam keep vectors simple and explain more complex bypasses verbally. ([OWASP Cheat Sheet Series][9])

---

## 9) What to capture & sample evidence filenames (put these in `~/expt06/evidence/`)

1. `evidence/01_reflected_request.txt` — raw HTTP request that you modified (Repeater save).
2. `evidence/02_reflected_response.png` — screenshot of the page response with payload reflected or alert popup.
3. `evidence/03_stored_post_request.txt` — raw POST used to save comment/profile.
4. `evidence/04_stored_view.png` — screenshot showing stored payload executed on page.
5. `evidence/05_dom_poc.png` — DevTools showing JS sink (`innerHTML`, `eval`) with payload in memory.
6. `evidence/06_dom_alert.png` — screenshot of DOM XSS alert or console showing `document.cookie`.
7. `commands.txt` — terminal commands you ran (curl, nmap optional).
8. `finding_summary.md` — concise one-page summary (template below).

**How to save:** In Burp you can right-click Repeater/Proxy requests → **Save item**. Use `gnome-screenshot -a -f ~/expt06/evidence/<name>.png` for screenshots.

---

## 10) Mitigations / recommended fixes (copy-paste lines for viva)

- **Contextual output encoding:** encode data before inserting into HTML, attributes, JavaScript, CSS or URL contexts — use the correct encoder for the context. (OWASP XSS Prevention Cheat Sheet) ([OWASP Cheat Sheet Series][10])
- **Validate / sanitize input:** apply allow-lists where possible and validate length/type on server side. ([OWASP][11])
- **Use secure frameworks and templating:** prefer frameworks that auto-escape output (e.g., use template engines that escape HTML by default).
- **Content Security Policy (CSP):** add a strong CSP to restrict inline scripts and external sources (defense-in-depth). ([OWASP Cheat Sheet Series][10])
- **Avoid dangerous sinks in client JS:** don’t use `innerHTML`, `eval`, `document.write` with untrusted data; use `textContent` or safe DOM APIs instead. (DOM XSS prevention) ([OWASP Cheat Sheet Series][7])
- **HttpOnly cookie flag:** prevents JS from reading session cookies (mitigates exploitation impact).
- **Escaping & canonicalization:** canonicalize input before validation, then escape on output.

---

## 11) Minimal lab report template (copy-paste into `finding_summary.md`)

```
# Finding Summary — EXPT-06 XSS (Reflected / Stored / DOM)
**Student:** <Your Name>
**Date:** <dd-mm-yyyy>
**Target:** http://localhost/mutillidae/
**Tools:** Kali Linux, Burp Suite (Repeater/Proxy), Firefox DevTools

## Steps performed
1. Located candidate reflected parameter (search or image Q) and tested with `<script>alert(1)</script>` using Burp Repeater.
2. Posted a comment (stored input) containing `<script>alert('XSS-stored')</script>` and viewed it in the comment list.
3. Inspected client-side scripts in DevTools, found `innerHTML` sink that uses `location.hash`, proved DOM XSS by loading `#<img src=x onerror=alert(1)>`.
4. Saved all raw requests and screenshots to `evidence/`.

## Key findings
- [High] Reflected XSS at `/somepath?param=` — PoC and request/response saved in `evidence/01_reflected_request.txt` and `evidence/02_reflected_response.png`.
- [High] Stored XSS in comments — PoC saved in `evidence/03_stored_post_request.txt` and `evidence/04_stored_view.png`.
- [High] DOM XSS via `location.hash` → `innerHTML` sink — DevTools evidence: `evidence/05_dom_poc.png`, `evidence/06_dom_alert.png`.

## Remediations
- Apply contextual output encoding, sanitize inputs, avoid `innerHTML`/`eval` sinks and implement CSP. Use HttpOnly cookies and server-side validation.

## Commands run (examples)
- curl -I http://localhost/mutillidae/
- (Saved items via Burp GUI)

## Conclusion
Demonstrated reflected, stored and DOM XSS in lab target. Recommended immediate fixes: encode outputs, use CSP, and remove unsafe DOM sinks. All evidence in `~/expt06/evidence/`.
```

---

## 12) Appendix — commands, Burp tips & quick checklist

```bash
# workspace
mkdir -p ~/expt06/evidence
cd ~/expt06

# quick header check
curl -I http://localhost/mutillidae/ > ~/expt06/commands.txt

# take screenshot (select area)
gnome-screenshot -a -f ~/expt06/evidence/02_reflected_response.png
```

**Burp quick tips**

- Add the host to **Target → Scope** to keep the Site map clean.
- Use **Proxy → HTTP history** to find candidate requests; right-click → **Send to Repeater** for iterative tests.
- Save a single raw request/response as canonical PoC (Burp → right-click → Save item).
- If the payload is filtered, try encoding (`%3C` etc.) or alternate vectors from PortSwigger/OWASP cheat sheets. ([PortSwigger][4])

---

## References & further reading (useful for viva)

- OWASP XSS Prevention Cheat Sheet. ([OWASP Cheat Sheet Series][10])
- OWASP XSS overview & testing guidance. ([OWASP][1])
- PortSwigger: Reflected / Stored / DOM XSS documentation and labs. ([PortSwigger][2])
- Mutillidae XSS tutorials and walkthroughs (example lab walkthroughs). ([melmols][12])

---

### Final exam strategy

1. Demonstrate one clean PoC for each XSS type (Reflected / Stored / DOM) with saved raw request and screenshot.
2. Explain impact briefly (cookie theft, session theft, UI redress, CSRF pivot).
3. Present mitigations (contextual encoding, CSP, HttpOnly cookies, avoid `innerHTML`).
4. Keep everything in `~/expt06/evidence/` and show `finding_summary.md` first — it summarises your work in a minute.

---
